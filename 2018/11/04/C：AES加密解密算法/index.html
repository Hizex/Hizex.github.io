<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.png"/>
	<link rel="shortcut icon" href="/img/favicon.png">
	
			    <title>
    zero
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="box" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/nov7.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">box</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(../images/1.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C：AES加密解密算法</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>一开学就猝不及防来了个密码学算法程序设计。。。仿佛又回到上学期末被密码学支配的恐惧，最早五月的一科考试，全寝室就我一人考密码学啊喂喂喂。<br>行8终于码完了AES，猪命要紧， <strong>在 也 不 熬 夜 了 ！！</strong><br><img src="/images/aha.jpg"><br><a id="more"></a></p>
<h1 id="AES算法原理简单介绍"><a href="#AES算法原理简单介绍" class="headerlink" title="AES算法原理简单介绍"></a>AES算法原理简单介绍</h1><p>AES算法中，初始状态矩阵由为128bits明文分组构成，以字节为单位，则总共有16bytes。<br>AES的基本运算单位是字节（Byte），加密和解密过程都是在一个4*4的字节矩阵上运作，这个矩阵又称为“体（state）”或者“状态”。字节矩阵初始值是一个明文块（块/分组，block）。<br><img src="/images/AES-1.png" title="[初始字节矩阵]"><br>加密和解密过程都需要进行密钥扩展：Rijndael算法的密钥同样以字节为单位进行变换，用一个4行的二维矩阵来表示。密钥按照矩阵的列进行分组，密钥比特的总数等于明文分组长度乘以轮数加1。</p>
<h2 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h2><img src="/images/AES-2.png" title="[AES算法加密结构]">
<h3 id="字节代替"><a href="#字节代替" class="headerlink" title="字节代替"></a>字节代替</h3><p>字节代替（SubBytes）：通过一个非线性的替换函数，用查找S盒表的方式把每个字节替换成对应的字节。S盒是一个16*16的矩阵。</p>
<h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p>行移位（ShiftRows）：将矩阵中的每行以字节为单位进行循环左移位。每一行循环左移的偏移量由明文分组的大小和所在行数共同决定。</p>
<h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>列混合（MixColumns）：为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每行内的四个字节。将输入的状态矩阵的每列与一固定的多项式在有限域GF（2^8）上的相乘，然后模多项式x^4+1。</p>
<h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加（AddRoundKey）：将列混合的输出状态矩阵中的每一个字节都与该次循环的子密钥做异或逻辑运算。</p>
<h2 id="AES解密算法"><a href="#AES解密算法" class="headerlink" title="AES解密算法"></a>AES解密算法</h2><img src="/images/AES-3.png" title="[AES算法解密结构]">
<h3 id="逆行移位"><a href="#逆行移位" class="headerlink" title="逆行移位"></a>逆行移位</h3><p>逆行移位（InvShifrRows）：将矩阵中的每行以字节为单位进行循环右移位。</p>
<h3 id="逆字节替代"><a href="#逆字节替代" class="headerlink" title="逆字节替代"></a>逆字节替代</h3><p>逆字节替代（InvSubBytes）：与加密过程的字节替代相似，将输入的状态矩阵的每一个字节通过查表操作替换为表中对应字节，只是查表操作变为查逆S盒。</p>
<h3 id="逆列混合"><a href="#逆列混合" class="headerlink" title="逆列混合"></a>逆列混合</h3><p>逆列混合（InMixColumns）：使用另一个常数矩阵乘以矩阵state得到新的state矩阵。</p>
<h3 id="轮密钥加-1"><a href="#轮密钥加-1" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加（AddRoundKey）：矩阵中的每一个字节都与该次循环的子密钥做异或逻辑运算。</p>
<h1 id="核心模块的函数说明和实现方式"><a href="#核心模块的函数说明和实现方式" class="headerlink" title="核心模块的函数说明和实现方式"></a>核心模块的函数说明和实现方式</h1><img src="/images/AES-5.png" title="[函数调用结构图]">
<h2 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h2><p>使用二维无符号字符数组k[44][4]来存放每一轮的轮密钥，每一轮轮密钥为128bit。<br><img src="/images/AES-4.png" title="[轮密钥选择]"><br>当k的行数i不是4的倍数时，Ki=Ki-4⊕Ki-1；当k的行数i是4的倍数时，Ki=Ki-4⊕T（Ki-1）。T（）函数的运算方法如下：<br>（1）将Ki-1列以字节为单位循环左移1字节；<br>（2）将循环左移之后的输出进性字节代替；<br>（3）根据Rocn常量表得到Rcon[i/Nk]值；<br>（4）将步骤2与步骤3的结果异或。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void extendKey()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		if( kNum%4 != 0)&#123;</span><br><span class="line">			for(j=0; j&lt;4; j++&#123;</span><br><span class="line">				k[kNum][j] = k[kNum-4][j] ^ k[kNum-1][j];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;else&#123;for(j=0; j&lt;3; j++)&#123;//左移动1字节</span><br><span class="line">				tmp[j] = k[kNum-1][j+1];&#125;</span><br><span class="line">			tmp[j] = k[kNum-1][0];	//0-&gt;4</span><br><span class="line">			//字节代替</span><br><span class="line">			for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">					left = tmp[j] &gt;&gt; 4;</span><br><span class="line">				right = tmp[j] &lt;&lt; 4;</span><br><span class="line">				right = right &gt;&gt; 4;</span><br><span class="line">				tmp[j] = Sbox[left][right];</span><br><span class="line">				&#125;</span><br><span class="line">			rc = Rcon[ kNum/4];</span><br><span class="line">			tmp[0] = tmp[0] ^ rc;</span><br><span class="line">			for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">				k[kNum][j] = k[kNum-4][j] ^ tmp[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		kNum++;</span><br><span class="line">		if(kNum %4 == 0)&#123;</span><br><span class="line">			return ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字节替代"><a href="#字节替代" class="headerlink" title="字节替代"></a>字节替代</h2><p>由于定义的数组为4*4矩阵，所以需要取出数组中值的左4个bit作为S盒的列输入，右4个bit作为S盒的行输入。使用C语言中的左移运算符&lt;&lt;及右移运算符&gt;&gt;来获取4bit的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">	for(j=0; j&lt;4; j++)&#123;	</span><br><span class="line">		right = k[(roundNum-1)*4+i][j] &gt;&gt; 4;</span><br><span class="line">		left = k[(roundNum-1)*4+i][j] &lt;&lt; 4;</span><br><span class="line">		left = left &gt;&gt; 4;</span><br><span class="line">		resOfSub[i][j] = Sbox[left][right]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/AES-7.png"></p>
<h2 id="行移位-1"><a href="#行移位-1" class="headerlink" title="行移位"></a>行移位</h2><p>第i行循环左移i-1列，shiftnum标记左移列数，resOfSub为前一次字节代替的结果，resOfRows为本次行移位的输出结果。逆行移中，第i行循环右移动i-1列，可看作循环左移4-i列。<br>这个一开始绕了好久写不出来。。。后来哎嘛不就是两个循环么。。。内层循环是每次左移1位，外层循环是将内层执行i-1次。i=1，2，3，4（行）。每行只需要使用一次tmp存第一个元素，然后执行循环左移1bit，移动完成后再将tmp放入最后一个位置。<br>加密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shiftnum=0;</span><br><span class="line">	for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">		for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">			resOfRows[j][i] = resOfSub[(shiftnum+j)%4][i];</span><br><span class="line">			&#125;</span><br><span class="line">		shiftnum++;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><br>解密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shiftnum=4;</span><br><span class="line">	for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">		for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">				resOfRows[j][i] = resOfKey[(shiftnum+j)%4][i];</span><br><span class="line">				&#125;</span><br><span class="line">			shiftnum--;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/AES-8.png">        </p>
<h2 id="列混合-1"><a href="#列混合-1" class="headerlink" title="列混合"></a>列混合</h2><p>列混合是输入矩阵的每列与固定矩阵每行相乘，元素做域上乘法。由于固定矩阵每一行的元素0x02、0x03、0x01、0x01不变，仅顺序改变，Ki行元素为Ki-1行元素循环右移1列得到，故在进行每一行的运算的时候，没有引入矩阵数组，直接将固定矩阵的元素循环使用。<br>例如，（i，j）为输入矩阵第i行每个元素乘以固定矩阵的第j列每个元素，（i，j+1）为输入矩阵第j行乘以第j+1列。而固定矩阵的j+1列为j列循环移动1位得到，即可直接将0x02、0x03、0x01、0x01移动一位，再乘以输入矩阵i行。<br>原本是将输入矩阵与固定矩阵都定义为4*4二维数组来进行运算，但不晓得为啥运算结果老是出错。意识到固定矩阵每行的元素是由上一行循环右移1位得到，所以其实可以不需要列出固定矩阵二维数组。比如在计算第一行的输出结果时，是由矩阵A第一行的每个元素分别与矩阵B第一、二、三、四列每个元素运算得到（1，1）、（1，2）、（1，3）、（1，4），由于固定矩阵的每列元素相同，只是顺序移动1位，（2311-&gt;1231-&gt;1123-&gt;3112），我们可以取第一行值2311作为固定，与输入矩阵的某行做运算时候，输入矩阵的行按照每次移动1位的顺序与2311做运算。<br>加密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">	for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">		resOfCols[i][j] = GF02(resOfRows[i][j%4]) ^ GF03(resOfRows[i][(j+1)%4]) ^ GF01(resOfRows[i][(j+2)%4]) ^ GF01(resOfRows[i][(j+3)%4]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>解密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">	for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">		resOfCols[i][j] = GF0E(resOfKey[i][j%4]) ^ GF0B(resOfKey[i][(j+1)%4]) ^ GF0D(resOfKey[i][(j+2)%4]) ^ GF09(resOfKey[i][(j+3)%4]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/AES-9.png">        </p>
<h2 id="轮密钥加-2"><a href="#轮密钥加-2" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>将输入与当轮轮密钥左异或运算。<br>加密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">	for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">		resOfKey[i][j] = k[kNum-4+i][j] ^ resOfRows[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>解密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">	for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">		resOfKey[i][j] = k[44-(roundNum+1)*4+i][j] ^ resOfSub[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/AES-6.png"></p>
<h2 id="域上乘法"><a href="#域上乘法" class="headerlink" title="域上乘法"></a>域上乘法</h2><p>写了多个子函数层层调用，但是最终都是调用GF02函数，即域上乘以0x02的算法。当判断b7为0或者1的时候，思考了三种算法：（1）比较b与0x08的大小，若b&gt;=0x80，则b7=1；反之，得b7=0。（2）判断b&amp;0x08是否为0，若为0，则b7=0；反之，得b7=1。（3）使用移位符，b&gt;&gt;7，将b右移7个bit，若 b&gt;&gt; == 0x01，则b7=1；反之，得b7=0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">unsigned char GF01(unsigned char b)&#123;</span><br><span class="line">	return b ;</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF02(unsigned char b)&#123;</span><br><span class="line">	if (b &amp; 0x80)&#123;</span><br><span class="line">		return (b&lt;&lt;1);//&amp;0xff; </span><br><span class="line">		&#125;else&#123;</span><br><span class="line">		return ((b&lt;&lt;1)^0x1b);//&amp;0xff; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF03(unsigned char b)&#123;</span><br><span class="line">	return  b ^ GF02(b);</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF04(unsigned char b)&#123;</span><br><span class="line">	return GF02( GF02(b) );</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF08(unsigned char b)&#123;</span><br><span class="line">	return GF04( GF02(b) );</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF09(unsigned char b)&#123;</span><br><span class="line">	return b ^ GF08(b);</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF0B(unsigned char b)&#123;</span><br><span class="line">	return GF03(b) ^ GF08(b);</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF0D(unsigned char b)&#123;</span><br><span class="line">	return GF04(b) ^ GF08(b) ^ GF01(b);</span><br><span class="line">	&#125;</span><br><span class="line">unsigned char GF0E(unsigned char b)&#123;</span><br><span class="line">	return GF04(b) ^ GF08(b) ^ GF02(b);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="将数据写入txt文件"><a href="#将数据写入txt文件" class="headerlink" title="将数据写入txt文件"></a>将数据写入txt文件</h2><p>由于输入数据时候，每次输入二维数组[4][4]的一个字节，比如0xab、0x0a，而当值小于等于0x0f时候，左4bit的0并不会被存入文件，将导致数据不全，不足32个十六进制数。而从文件读取数据的时候，使用fgets函数将一行数据取出放入数组，使用一个临时数组[32]来存放每1个十六进制数的值，最后在将左4bit与后4bit整合为一个byte放入[4][4]二维矩阵。 但若存入txt的时候，没有将0存放进去，读取文件内容的时候就会读取错误，无法判断缺少的0x00的位置。所以在写数据到txt文件的时候，添加一个判断条件，若值&lt;=0x0f，则向txt文件写入一个0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void write()&#123;</span><br><span class="line">	FILE *fp;//定义文件指针</span><br><span class="line">	fp=fopen(&quot;aes.txt&quot;,&quot;a&quot;);</span><br><span class="line">	if(fp==NULL)&#123; //判断指针是否为空，安全检查</span><br><span class="line">		printf(&quot;error&quot;);</span><br><span class="line">		return ;</span><br><span class="line">		&#125;</span><br><span class="line">	fprintf(fp,&quot;%s&quot;,a);	</span><br><span class="line">	for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">		for(j=0;j&lt;4;j++)&#123;	</span><br><span class="line">			if(plaintext[i][j] &lt;= 0x0f)&#123;</span><br><span class="line">				fprintf(fp,&quot;0&quot;);&#125;</span><br><span class="line">			fprintf(fp,&quot;%x&quot;,plaintext[i][j]); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	fprintf(fp,&quot;%s&quot;,b);</span><br><span class="line">	for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">		for(j=0;j&lt;4;j++)&#123;</span><br><span class="line">			if(resOfKey[i][j] &lt;= 0x0f)&#123;</span><br><span class="line">				fprintf(fp,&quot;0&quot;);			</span><br><span class="line">				&#125;</span><br><span class="line">			fprintf(fp,&quot;%x&quot;,resOfKey[i][j]); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	fclose(fp);//关闭文件</span><br><span class="line">//	fp=NULL;//置空指针，否则指向打开原文件的地址</span><br></pre></td></tr></table></figure></p>
<h2 id="从txt文件读取数据"><a href="#从txt文件读取数据" class="headerlink" title="从txt文件读取数据"></a>从txt文件读取数据</h2><p>使用fgets函数将txt内容一行一行的读取打印，并将第一组密文与密钥存入数组，做AES解密测试。由于从txt读取的数值是ASCII码，所以还需要将ASCII码转换为十进制数字。读取密文的时候每次只能将一个字符存入数组，这一个字符仅代表4bit、一个十六进制数。转换成4*4矩阵，将存放了32个十六进制数的数组[32]中，若i%2==0，第i个数字左移4bit，再执行tmp[i]^tmp[i+1]，即将2个4bit存放到同一个1byte空间中。<br>C语言中，一个中文占2byte，txt文件中固定格式“密文：0x”,所以当取出当前行字符串时，s[0]-s[7]为格式内容，s[8]开始为密文数据，故定义n=8，从第8个数据开始存入密文数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void read()&#123;</span><br><span class="line">		FILE *rfp;</span><br><span class="line">	rfp=fopen(&quot;aes.txt&quot;,&quot;r&quot;);</span><br><span class="line">	if(rfp==NULL)&#123;</span><br><span class="line">		printf(&quot;error\n&quot;);</span><br><span class="line">		return ;</span><br><span class="line">		&#125;</span><br><span class="line">	while (fgets(line, sizeof(line), rfp)) &#123; </span><br><span class="line">		//fgets逐行读取文件，到达文件尾终止while循环</span><br><span class="line">		sscanf(line, &quot;%s&quot;, str);</span><br><span class="line">		printf(&quot;%s\n&quot;, str); //打印，测试结果</span><br><span class="line">		if( i == 2)&#123;</span><br><span class="line">			n=8;</span><br><span class="line">			printf(&quot;密文0x：&quot;);</span><br><span class="line">			for( j=0; j&lt;4; j++)&#123;</span><br><span class="line">				for(k=0; k&lt;8; k++)&#123;</span><br><span class="line">					if( str[n] &gt;=48 &amp;&amp; str[n] &lt;=57 )&#123;</span><br><span class="line">						tmpcipher[j][k] = (unsigned char)str[n++]-48;</span><br><span class="line">					&#125;else	&#123;</span><br><span class="line">					tmpcipher[j][k] = (unsigned char)str[n++]-97+10;</span><br><span class="line">					&#125;</span><br><span class="line">					printf(&quot;%x&quot;,ciphertext[j][k] );</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				i++;</span><br><span class="line">				&#125;</span><br><span class="line">	for(i=0; i&lt;4; i++)&#123;</span><br><span class="line">		for(j=0; j&lt;4; j++)&#123;</span><br><span class="line">			right = tmpcipher[i][j*2] &lt;&lt; 4;</span><br><span class="line">			ciphertext[i][j] = right ^ tmpcipher[i][j*2+1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	fclose(rfp);rfp=NULL;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/11/04/C：AES加密解密算法/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/11/04/C：AES加密解密算法/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2020总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":220,"height":440},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":220,"height":440},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>



 	
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
